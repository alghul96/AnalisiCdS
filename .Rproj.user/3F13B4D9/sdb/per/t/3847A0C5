{
    "collab_server" : "",
    "contents" : "library(epicalc)\n\n# load dataset\n\nwhas <- read.dta(\"whas2.dta\", \n convert.dates=TRUE, convert.factors=TRUE, missing.type=TRUE, \n convert.underscore=TRUE, warn.missing.labels=TRUE)\n\n\nuse(whas)\n# information on variables\ndes()\n# descriptive statistics\nsumm()\n\n#note the asymmetry of cpk variable\n\nhist(whas$cpk)\n\n# use log transformation\nhist(log(whas$cpk))\n\n# load library for survival analysis\nlibrary(survival)\n\n\n\n# Create the survival data object\nmsurv<- Surv(lenfol, fstat == \"Dead\")\n# descriptive analysis and Kaplan-Meier estimate\n\nmfit <- survfit((msurv)~1)\noptions(survfit.print.mean = TRUE)\nmfit\nsummary(mfit)\n\n#Moltiplicando il valore precedente per la stima della probabilit? condizionata\n# otteniamo il valore della stima incondizionata del blablabla (cazzo devi seguire)\n# per vedere il tempo mediano di sopravvivenza vedo quando pi? o meno la funzione di sopravvivenza va al di sotto del valore di 0.5\n# (nel nostro caso si tratta di 2335)\n# Allo stesso modo per quanto riguarda il venticinquesimo percentile dobbiamo vedrre quello con 0.75 (ovver il 205)\n# mentre quello del 75esimo non arriviamo a stimarlo in quanto ci fermiamo allo 0.38\n\nplot(mfit)\n\n###############################################################\n######### Stima della funzione di rischio cumulata ############\n###############################################################\n\n# estimate the cumulative hazard function\n\nmy.fit <- summary(mfit) #questo oggetto vciene creato dal summary di mfit contiene l'elemento surv\nH.hat <- -log(my.fit$surv); # che ? proprio lo stimatore della funzione di kaplan mayer\nH.hat <- c(H.hat, H.hat[length(H.hat)]) # a questo oggetto si aggiunge un ulteriore elemento per rappresentarlo graficamrente\n\nplot(c(my.fit$time, my.fit$time[length(my.fit$time)]+1),H.hat,type=\"s\") # e quindi si plotta\nplot(mfit, fun=\"cumhaz\") #oppure questa ? la funzione automatica \n\n# plot KM estimate\n\n###########################################\n# FUN option of plot.survfit\n###########################################\n#an arbitrary function defining a transformation of the survival curve. \n#For example fun=log is an alternative way to draw a log-survival curve (but with the axis labeled with log(S) values), \n#and fun=sqrt would generate a curve on square root scale. Four often used transformations can be specified with a character argument instead: \n#\"log\" is the same as using the log=T option, \n#\"event\" plots cumulative events (f(y) = 1-y), \n#\"cumhaz\" plots the cumulative hazard function (f(y) = -log(y)), \n#and \"cloglog\" creates a complimentary log-log survival plot (f(y) = log(-log(y)) along with log scale for the x-axis)----\"log minus log\".\n\nplot(mfit, fun=\"cloglog\")\n\n#####################################################################\n\n###############################################\n### plot of KM estimate for some covariates ###\n###############################################\n# Going bak to our analysis\n\n# Create KM estimates broken out by miord\nmfit.bymiord<-survfit((msurv)~miord)\n\n# nell'output ? possibile vedere che il secondo intervallo di confidenza non viene riportato \nplot(mfit.bymiord)\n# in questo grafico vediamo la stima delle due curve, una con miord recurrent e l'altra meno\n# la differenza tra le due curve comunque si nota!\n# with confidence band\nplot(mfit.bymiord, conf.int = TRUE, col = c(\"black\", \"red\"), lty = 1:2)\nlegend(locator(1), legend=c(\"First\",\"Recurrent\"), lty=1:2)\n# vediamo che in questo grafico la curva nera ? quella del gruppo di coloro che sono \n# al primo infarto, mentre quella in rosso ? la sopravvivenza stimata di coloro che sono al \n# secondo o ad un superiore infarto\n \n\n#plot of log-minus-log function\n\nplot(mfit.bymiord, fun=\"cloglog\", col = c(\"black\", \"red\"), \nlty = 1:2)\n\n\n\n\n# Create KM estimates broken out by mitype\n\n\nmfit.bymitype<-survfit((msurv)~mitype)\nplot(mfit.bymitype)\n# with confidence band\nplot(mfit.bymitype, conf.int = TRUE, col = c(\"black\", \"red\"), lty = 1:2)\nlegend(locator(1), legend=c(\"Q-wave\",\"non-Q-wave\"), lty=1:2)\n\n#plot of log-minus-log function\n\nplot(mfit.bymitype, fun=\"cloglog\", col = c(\"black\", \"red\"), \nlty = 1:2)\n\n\n################################\n# passiamo quindi i test\n\n\n# Log rank test for miord\nsurvdiff(msurv~miord, rho=0)\n# Questo test ci restituisce gli eventi osservati, quelli attesi e \n# altre mirabolanti cose che sarebbero gli osservati meno gli attesi. \n# il p-value ? piccolo e quindi si rifiuta l'ipotesi nulla che le due curve\n# siano uguali tra di loro. \n\n# Peto test \nsurvdiff(msurv~miord, rho=1)\n# Anche se applichiamo il test di peto anche questo infulisce sugli attesi\n# e anche questo test ci riporta a rifiutare l'hp nulla. \n\n# altre variabili \n# Log rank test for mitype\nsurvdiff(msurv~mitype, rho=0)\n# Peto test \nsurvdiff(msurv~mitype, rho=1)\n# Se valutiamo il risultato qui ci accorgiamo che il log-rank test ? pari a 0.13\n# ma questa variabile non ha rischi proporzionali, quindi in teoria\n# siam portati a non rifiutare l'hp nulla anche se alla fine sembra \n# da rifiutare. \n# se vediamo il test di peto, invece, che ? capace di valutare la situazione anche \n# quando ? rifiutato l'assunto di rischi proporzionali, siamo sicurdi di poter\n# accettare l'ipotesi.\n\n\n# TEST DEL LOG RANK SU VARIABILE CONTINUA\n# Log rank test for agecl\nsurvdiff(msurv~agecl, rho=0)\nmfit.agecl<-survfit((msurv)~agecl)\nplot(mfit.agecl)\n\n\n\n#########################\n# univariate COX regression model\n#########################\n\ncox.bymiord<-coxph(msurv ~ miord , iter.max=20)\ncox.bymitype<-coxph(msurv ~ mitype , iter.max=20)\ncox.bysex<-coxph(msurv ~ sex, iter.max=20)\n\ncox.byage<-coxph(msurv ~ age , iter.max=20)\ncox.byagecl<-coxph(msurv ~ factor(agecl) , iter.max=20)\n\ncox.bysho<-coxph(msurv ~ sho , iter.max=20)\ncox.bychf<-coxph(msurv ~ chf , iter.max=20)\n\ncox.bycpk<-coxph(msurv ~ cpk , iter.max=20)\ncox.bycpkcl<-coxph(msurv ~ factor(cpkcl) , iter.max=20)\n\nsummary(cox.bymiord)\nsummary(cox.bymitype)\nsummary(cox.bysex)\n\nsummary(cox.byage)\nsummary(cox.byagecl)\n\nsummary(cox.bysho)\nsummary(cox.bychf)\n\nsummary(cox.bycpk)\nsummary(cox.bycpkcl)\n\n\n# complete model\ncox.comp <- coxph(msurv ~ factor(agecl) + miord+mitype + chf+sho+sex+factor(cpkcl), iter.max=12)\n\n# Assess PH by estimating log relative hazard over time\n# we could save scaled shoenfeld residual and plot them versus time or log(time)\n\n# Andiamo a vedere se l'ipotesi del modello di cox ? stata mantenuta\n# quella dei rischi proprozionali\n\nr <- resid(cox.comp, \"scaledsch\")\n# more easy\n\n# Andiamo a vedere se l'ipotesi del modello di cox ? stata mantenuta\n# quella dei rischi proprozionali\n# Ci sono tre tipi di residui di schenfel. \n# Quelli scalati, quelli non scalati e un terzo che non ricordo come si chiama\n\n# Questa funzione permette di stimare questi residui, permette di fare test\n# su questi residui e creare dei grafici di questi residui nel tempo \n\nplot(cox.zph(cox.comp))    # invokes plot.cox.zph\n\n# In questo grafico son messi i grafici uno dopo l'altro, non si capisce un cazz\n\nzph.comp<- cox.zph(cox.comp, transform = 'log')\npar(mfrow=c(3,3))\nplot(zph.comp[1])\nabline(h=0, lty=3)\nplot(zph.comp[2])\nabline(h=0, lty=3)\nplot(zph.comp[3])\nabline(h=0, lty=3)\nplot(zph.comp[4])\nabline(h=0, lty=3)\nplot(zph.comp[5])\nabline(h=0, lty=3)\nplot(zph.comp[6])\nabline(h=0, lty=3)\nplot(zph.comp[7])\nabline(h=0, lty=3)\nplot(zph.comp[8])\nabline(h=0, lty=3)\nplot(zph.comp[9])\nabline(h=0, lty=3)\n\n# Su alcuni grafici, tolte le et?, si pu? rilevar eun andamento\n# allora si crea un test che dovrebbe cercare il coefficiente di \n# correlazione linerare tra ciascuno di questi residui e il tempo. \n\nprint(zph.comp)\n\n\n# vediamo che mitype e cpkcl dell'ultima classe pu? dare noia \n# Quindi in teoria l'uniche correlazioni lineari potrebbero essere quelle l?",
    "created" : 1493730984070.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1402010842",
    "id" : "3847A0C5",
    "lastKnownWriteTime" : 1493732479,
    "last_content_update" : 1493732479230,
    "path" : "~/GitHub/AnalisiCdS/sintassi whas.R",
    "project_path" : "sintassi whas.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}